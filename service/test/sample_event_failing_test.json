{"testFiles":{"healthcheck.test.js":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./sanities/healthcheck.test.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./constants/constants.js\":\n/*!********************************!*\\\n  !*** ./constants/constants.js ***!\n  \\********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/*\n * Declares constants used across multiple tests\n *\n * const env = (global.SANITY_VARIABLES.APP_ENV == 'CA') ? ('CA') : ('US')\n * const constants = require('./constants/constants')[env];\n *\n */\n\ncommonConstants = {\n    defaultTimeout: 60000\n};\n\nconstants = {\n    CA: {\n        TEST_COURSE_ID: '689316',\n        TEST_PRESENTATION_COURSE_ID: '681616',\n        TEST_SLIDE_TRANSITION_COURSE_ID: '219184',\n        TEST_SLIDE_PRESENTATION_MODULE_ITEM_ID: '2517968',\n        URL: \"https://app-ca.tophat.com\",\n        USERNAME_PROF: \"sanity+prof0@tophatmonocle.com\",\n        USERNAME_STUD: \"sanity+stud0@tophatmonocle.com\",\n        PASSWORD: \"1q2w3e\",\n        SCHOOL: \"Professor Test Organization CA\",\n        CREDIT_CARD_SECRET_KEY: \"sanity_runner/credit_card\",\n        COUPON_CODE_SECRET_KEY: \"sanity_runner/coupon_code_ca\",\n        SENDGRID_API_SECRET_KEY: \"sanity_runner/sendgrid_api\",\n        SMS_RESPONSE: {\n            COURSE_ID: '037565',\n            PINPOINT_PROJECT_NAME: \"sanity-runner-us\",\n            USERNAME_STUD: \"devops+monitoringsanitysms2@tophat.com\"\n        },\n        ANON_ACCESS: {\n            COURSE_ID: '212127',\n            EXPECTED_RESULT: 'Anon Access'\n        },\n        COURSE_SEARCH: {\n            EXPECTED_RESULT: 'Canadian History'\n        },\n        STUDENT_MANAGER: {\n            EXPECTED_RESULT: 'Top Hat: Invitation to join course'\n        }\n    },\n    US: {\n        TEST_COURSE_ID: '366847',\n        TEST_PRESENTATION_COURSE_ID: '725989',\n        TEST_SLIDE_TRANSITION_COURSE_ID: '658021',\n        TEST_SLIDE_PRESENTATION_MODULE_ITEM_ID: '131841210',\n        URL: \"https://app.tophat.com\",\n        USERNAME_PROF: 'sanity+prof0@tophatmonocle.com',\n        USERNAME_STUD: 'sanity+stud0@tophatmonocle.com',\n        PASSWORD: \"1q2w3e\",\n        SCHOOL: \"Top Hat University - Demos\",\n        CREDIT_CARD_SECRET_KEY: \"sanity_runner/credit_card\",\n        COUPON_CODE_SECRET_KEY: \"sanity_runner/coupon_code_us\",\n        SENDGRID_API_SECRET_KEY: \"sanity_runner/sendgrid_api\",\n        SMS_RESPONSE: {\n            COURSE_ID: '095680',\n            PINPOINT_PROJECT_NAME: \"sanity-runner-us\",\n            USERNAME_STUD: \"devops+monitoringsanitysms2@tophat.com\"\n        },\n        ANON_ACCESS: {\n            COURSE_ID: '579905',\n            EXPECTED_RESULT: 'Anonymous Access'\n        },\n        COURSE_SEARCH: {\n            EXPECTED_RESULT: 'American History'\n        },\n        STUDENT_MANAGER: {\n            EXPECTED_RESULT: 'Top Hat: Invitation to join course'\n        },\n        IMPORT_FROM_MARKETPLACE: {\n            COURSE_ID: '521866',\n            COURSE_NAME: 'Monitoring 105'\n        },\n        OLD_PAID_REG: {\n            COURSE_ID: '736298'\n        }\n    },\n    STAGING: {\n        USERNAME_PROF: 'devops+sanityprofessor1560187595206@tophatmonocle.com',\n        USERNAME_STUD: 'devops+sanitystudent1560187595206@tophatmonocle.com',\n        CREDIT_CARD_SECRET_KEY: 'sanity_runner/credit_card',\n        COUPON_CODE_SECRET_KEY: 'sanity_runner/coupon_code_us',\n        SENDGRID_API_SECRET_KEY: 'sanity_runner/sendgrid_api',\n        SMS_RESPONSE: {\n            COURSE_ID: '217077',\n            PINPOINT_PROJECT_NAME: 'sanity-runner-us',\n            USERNAME_STUD: 'devops+monitoringsanitysms2@tophat.com'\n        },\n        PASSWORD: '1q2w3e',\n        SCHOOL: 'TopHat University',\n        URL: 'https://staging.dev.tophat.com',\n        TEST_COURSE_ID: '137559',\n        TEST_PRESENTATION_COURSE_ID: '111150',\n        TEST_SLIDE_TRANSITION_COURSE_ID: '777701',\n        ANON_ACCESS: {\n            COURSE_ID: '579905',\n            EXPECTED_RESULT: 'Anonymous Access'\n        },\n        COURSE_SEARCH: {\n            EXPECTED_RESULT: 'American History'\n        },\n        STUDENT_MANAGER: {\n            EXPECTED_RESULT: 'Top Hat: Invitation to join course'\n        },\n        IMPORT_FROM_MARKETPLACE: {\n            COURSE_ID: '926322'\n        }\n    }\n\n};\n\nconst env = process.env.APP_ENV ? process.env.APP_ENV : global.SANITY_VARIABLES.APP_ENV;\nmodule.exports = Object.assign({}, commonConstants, constants[env]);\n\n/***/ }),\n\n/***/ \"./node_modules/expect-puppeteer/lib/index.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/expect-puppeteer/lib/index.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint-disable no-use-before-define, no-restricted-syntax, no-await-in-loop */\n\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./node_modules/expect-puppeteer/lib/utils.js\");\n\nvar _notToMatch = __webpack_require__(/*! ./matchers/notToMatch */ \"./node_modules/expect-puppeteer/lib/matchers/notToMatch.js\");\n\nvar _notToMatch2 = _interopRequireDefault(_notToMatch);\n\nvar _notToMatchElement = __webpack_require__(/*! ./matchers/notToMatchElement */ \"./node_modules/expect-puppeteer/lib/matchers/notToMatchElement.js\");\n\nvar _notToMatchElement2 = _interopRequireDefault(_notToMatchElement);\n\nvar _toClick = __webpack_require__(/*! ./matchers/toClick */ \"./node_modules/expect-puppeteer/lib/matchers/toClick.js\");\n\nvar _toClick2 = _interopRequireDefault(_toClick);\n\nvar _toDisplayDialog = __webpack_require__(/*! ./matchers/toDisplayDialog */ \"./node_modules/expect-puppeteer/lib/matchers/toDisplayDialog.js\");\n\nvar _toDisplayDialog2 = _interopRequireDefault(_toDisplayDialog);\n\nvar _toFill = __webpack_require__(/*! ./matchers/toFill */ \"./node_modules/expect-puppeteer/lib/matchers/toFill.js\");\n\nvar _toFill2 = _interopRequireDefault(_toFill);\n\nvar _toFillForm = __webpack_require__(/*! ./matchers/toFillForm */ \"./node_modules/expect-puppeteer/lib/matchers/toFillForm.js\");\n\nvar _toFillForm2 = _interopRequireDefault(_toFillForm);\n\nvar _toMatch = __webpack_require__(/*! ./matchers/toMatch */ \"./node_modules/expect-puppeteer/lib/matchers/toMatch.js\");\n\nvar _toMatch2 = _interopRequireDefault(_toMatch);\n\nvar _toMatchElement = __webpack_require__(/*! ./matchers/toMatchElement */ \"./node_modules/expect-puppeteer/lib/matchers/toMatchElement.js\");\n\nvar _toMatchElement2 = _interopRequireDefault(_toMatchElement);\n\nvar _toSelect = __webpack_require__(/*! ./matchers/toSelect */ \"./node_modules/expect-puppeteer/lib/matchers/toSelect.js\");\n\nvar _toSelect2 = _interopRequireDefault(_toSelect);\n\nvar _toUploadFile = __webpack_require__(/*! ./matchers/toUploadFile */ \"./node_modules/expect-puppeteer/lib/matchers/toUploadFile.js\");\n\nvar _toUploadFile2 = _interopRequireDefault(_toUploadFile);\n\nvar _options = __webpack_require__(/*! ./options */ \"./node_modules/expect-puppeteer/lib/options.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst pageMatchers = {\n  toClick: _toClick2.default,\n  toDisplayDialog: _toDisplayDialog2.default,\n  toFill: _toFill2.default,\n  toFillForm: _toFillForm2.default,\n  toMatch: _toMatch2.default,\n  toMatchElement: _toMatchElement2.default,\n  toSelect: _toSelect2.default,\n  toUploadFile: _toUploadFile2.default,\n  not: {\n    toMatch: _notToMatch2.default,\n    toMatchElement: _notToMatchElement2.default\n  }\n};\n\nconst elementHandleMatchers = {\n  toClick: _toClick2.default,\n  toFill: _toFill2.default,\n  toFillForm: _toFillForm2.default,\n  toMatch: _toMatch2.default,\n  toMatchElement: _toMatchElement2.default,\n  toSelect: _toSelect2.default,\n  toUploadFile: _toUploadFile2.default,\n  not: {\n    toMatch: _notToMatch2.default,\n    toMatchElement: _notToMatchElement2.default\n  }\n};\n\nfunction createMatcher(matcher, page) {\n  return async function throwingMatcher(...args) {\n    if (typeof global.expect !== 'undefined') {\n      global.expect.getState().assertionCalls += 1;\n    }\n\n    try {\n      return await matcher(page, ...args);\n    } catch (error) {\n      Error.captureStackTrace(error, createMatcher);\n      throw error;\n    }\n  };\n}\n\nfunction internalExpect(type, matchers) {\n  const expectation = {\n    not: {}\n  };\n\n  Object.keys(matchers).forEach(key => {\n    if (key === 'not') return;\n    expectation[key] = createMatcher(matchers[key], type);\n  });\n\n  Object.keys(matchers.not).forEach(key => {\n    expectation.not[key] = createMatcher(matchers.not[key], type);\n  });\n\n  return expectation;\n}\n\nfunction expectPuppeteer(actual) {\n  const type = (0, _utils.getPuppeteerType)(actual);\n  switch (type) {\n    case 'Page':\n      return internalExpect(actual, pageMatchers);\n    case 'ElementHandle':\n      return internalExpect(actual, elementHandleMatchers);\n    default:\n      throw new Error(`${actual} is not supported`);\n  }\n}\n\nif (typeof global.expect !== 'undefined') {\n  const originalExpect = global.expect;\n  global.expect = (actual, ...args) => {\n    const type = (0, _utils.getPuppeteerType)(actual);\n    if (type) {\n      const matchers = expectPuppeteer(actual);\n      const jestMatchers = originalExpect(actual, ...args);\n      return _extends({}, jestMatchers, matchers, {\n        not: _extends({}, jestMatchers.not, matchers.not)\n      });\n    }\n    return originalExpect(actual, ...args);\n  };\n  Object.keys(originalExpect).forEach(prop => {\n    global.expect[prop] = originalExpect[prop];\n  });\n}\n\nmodule.exports = expectPuppeteer;\nmodule.exports.setDefaultOptions = _options.setDefaultOptions;\nmodule.exports.getDefaultOptions = _options.getDefaultOptions;\n\n/***/ }),\n\n/***/ \"./node_modules/expect-puppeteer/lib/matchers/notToMatch.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/expect-puppeteer/lib/matchers/notToMatch.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/expect-puppeteer/lib/utils.js\");\n\nvar _options = __webpack_require__(/*! ../options */ \"./node_modules/expect-puppeteer/lib/options.js\");\n\nasync function notToMatch(instance, matcher, options) {\n  options = (0, _options.defaultOptions)(options);\n\n  const { page, handle } = await (0, _utils.getContext)(instance, () => document.body);\n\n  try {\n    await page.waitForFunction((handle, matcher) => {\n      if (!handle) return false;\n      return handle.textContent.match(new RegExp(matcher)) === null;\n    }, options, handle, matcher);\n  } catch (error) {\n    throw (0, _utils.enhanceError)(error, `Text found \"${matcher}\"`);\n  }\n}\n\nexports.default = notToMatch;\n\n/***/ }),\n\n/***/ \"./node_modules/expect-puppeteer/lib/matchers/notToMatchElement.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/expect-puppeteer/lib/matchers/notToMatchElement.js ***!\n  \\*************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/expect-puppeteer/lib/utils.js\");\n\nvar _options = __webpack_require__(/*! ../options */ \"./node_modules/expect-puppeteer/lib/options.js\");\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nasync function notToMatchElement(instance, selector, _ref = {}) {\n  let { text } = _ref,\n      options = _objectWithoutProperties(_ref, ['text']);\n\n  options = (0, _options.defaultOptions)(options);\n\n  const { page, handle } = await (0, _utils.getContext)(instance, () => document);\n\n  try {\n    await page.waitForFunction((handle, selector, text) => {\n      const elements = handle.querySelectorAll(selector);\n      if (text !== undefined) {\n        return [...elements].every(({ textContent }) => !textContent.match(text));\n      }\n\n      return elements.length === 0;\n    }, options, handle, selector, text);\n  } catch (error) {\n    throw (0, _utils.enhanceError)(error, `Element ${selector}${text !== undefined ? ` (text: \"${text}\") ` : ' '}found`);\n  }\n}\n\nexports.default = notToMatchElement;\n\n/***/ }),\n\n/***/ \"./node_modules/expect-puppeteer/lib/matchers/toClick.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/expect-puppeteer/lib/matchers/toClick.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _toMatchElement = __webpack_require__(/*! ./toMatchElement */ \"./node_modules/expect-puppeteer/lib/matchers/toMatchElement.js\");\n\nvar _toMatchElement2 = _interopRequireDefault(_toMatchElement);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nasync function toClick(instance, selector, options) {\n  const element = await (0, _toMatchElement2.default)(instance, selector, options);\n  await element.click(options);\n}\n\nexports.default = toClick;\n\n/***/ }),\n\n/***/ \"./node_modules/expect-puppeteer/lib/matchers/toDisplayDialog.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/expect-puppeteer/lib/matchers/toDisplayDialog.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\nasync function toDisplayDialog(page, block) {\n  return new Promise(async resolve => {\n    const handleDialog = dialog => {\n      page.removeListener('dialog', handleDialog);\n      resolve(dialog);\n    };\n    page.on('dialog', handleDialog);\n    await block();\n  });\n}\n\nexports.default = toDisplayDialog;\n\n/***/ }),\n\n/***/ \"./node_modules/expect-puppeteer/lib/matchers/toFill.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/expect-puppeteer/lib/matchers/toFill.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _toMatchElement = __webpack_require__(/*! ./toMatchElement */ \"./node_modules/expect-puppeteer/lib/matchers/toMatchElement.js\");\n\nvar _toMatchElement2 = _interopRequireDefault(_toMatchElement);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nasync function toFill(instance, selector, value, options) {\n  const _ref = options || {},\n        { delay } = _ref,\n        toMatchElementOptions = _objectWithoutProperties(_ref, ['delay']);\n  const element = await (0, _toMatchElement2.default)(instance, selector, toMatchElementOptions);\n  await element.click({ clickCount: 3 });\n  await element.type(value, {\n    delay\n  });\n}\n\nexports.default = toFill;\n\n/***/ }),\n\n/***/ \"./node_modules/expect-puppeteer/lib/matchers/toFillForm.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/expect-puppeteer/lib/matchers/toFillForm.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _options = __webpack_require__(/*! ../options */ \"./node_modules/expect-puppeteer/lib/options.js\");\n\nvar _toFill = __webpack_require__(/*! ./toFill */ \"./node_modules/expect-puppeteer/lib/matchers/toFill.js\");\n\nvar _toFill2 = _interopRequireDefault(_toFill);\n\nvar _toMatchElement = __webpack_require__(/*! ./toMatchElement */ \"./node_modules/expect-puppeteer/lib/matchers/toMatchElement.js\");\n\nvar _toMatchElement2 = _interopRequireDefault(_toMatchElement);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-disable no-restricted-syntax, no-await-in-loop */\nasync function toFillForm(instance, selector, values, options) {\n  options = (0, _options.defaultOptions)(options);\n\n  const form = await (0, _toMatchElement2.default)(instance, selector, options);\n\n  for (const name of Object.keys(values)) {\n    await (0, _toFill2.default)(form, `[name=\"${name}\"]`, values[name], options);\n  }\n}\n\nexports.default = toFillForm;\n\n/***/ }),\n\n/***/ \"./node_modules/expect-puppeteer/lib/matchers/toMatch.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/expect-puppeteer/lib/matchers/toMatch.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/expect-puppeteer/lib/utils.js\");\n\nvar _options = __webpack_require__(/*! ../options */ \"./node_modules/expect-puppeteer/lib/options.js\");\n\nasync function toMatch(instance, matcher, options) {\n  options = (0, _options.defaultOptions)(options);\n\n  const { page, handle } = await (0, _utils.getContext)(instance, () => document.body);\n\n  const { text, regexp } = (0, _utils.expandSearchExpr)(matcher);\n\n  try {\n    await page.waitForFunction((handle, text, regexp) => {\n      if (!handle) return false;\n      if (regexp !== null) {\n        const [, pattern, flags] = regexp.match(/\\/(.*)\\/(.*)?/);\n        return handle.textContent.replace(/\\s+/g, ' ').trim().match(new RegExp(pattern, flags)) !== null;\n      }\n      if (text !== null) {\n        return handle.textContent.replace(/\\s+/g, ' ').trim().includes(text);\n      }\n      return false;\n    }, options, handle, text, regexp);\n  } catch (error) {\n    throw (0, _utils.enhanceError)(error, `Text not found \"${matcher}\"`);\n  }\n}\n\nexports.default = toMatch;\n\n/***/ }),\n\n/***/ \"./node_modules/expect-puppeteer/lib/matchers/toMatchElement.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/expect-puppeteer/lib/matchers/toMatchElement.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/expect-puppeteer/lib/utils.js\");\n\nvar _options = __webpack_require__(/*! ../options */ \"./node_modules/expect-puppeteer/lib/options.js\");\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nasync function toMatchElement(instance, selector, _ref = {}) {\n  let { text: searchExpr } = _ref,\n      options = _objectWithoutProperties(_ref, ['text']);\n\n  options = (0, _options.defaultOptions)(options);\n\n  const { page, handle } = await (0, _utils.getContext)(instance, () => document);\n\n  const { text, regexp } = (0, _utils.expandSearchExpr)(searchExpr);\n\n  const getElement = (handle, selector, text, regexp) => {\n    const elements = handle.querySelectorAll(selector);\n    if (regexp !== null) {\n      const [, pattern, flags] = regexp.match(/\\/(.*)\\/(.*)?/);\n      return [...elements].find(({ textContent }) => textContent.replace(/\\s+/g, ' ').trim().match(new RegExp(pattern, flags)));\n    }\n    if (text !== null) {\n      return [...elements].find(({ textContent }) => textContent.replace(/\\s+/g, ' ').trim().includes(text));\n    }\n    return elements[0];\n  };\n\n  try {\n    await page.waitForFunction(getElement, options, handle, selector, text, regexp);\n  } catch (error) {\n    throw (0, _utils.enhanceError)(error, `Element ${selector}${text !== null || regexp !== null ? ` (text: \"${text || regexp}\") ` : ' '}not found`);\n  }\n\n  const jsHandle = await page.evaluateHandle(getElement, handle, selector, text, regexp);\n  return jsHandle.asElement();\n}\n\nexports.default = toMatchElement;\n\n/***/ }),\n\n/***/ \"./node_modules/expect-puppeteer/lib/matchers/toSelect.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/expect-puppeteer/lib/matchers/toSelect.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _toMatchElement = __webpack_require__(/*! ./toMatchElement */ \"./node_modules/expect-puppeteer/lib/matchers/toMatchElement.js\");\n\nvar _toMatchElement2 = _interopRequireDefault(_toMatchElement);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction select(page, element, value) {\n  return page.evaluate((element, value) => {\n    if (element.nodeName.toLowerCase() !== 'select') throw new Error('Element is not a <select> element.');\n\n    const options = Array.from(element.options);\n    element.value = undefined;\n    for (const option of options) {\n      option.selected = value === option.value;\n      if (option.selected && !element.multiple) break;\n    }\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n    return options.filter(option => option.selected).map(option => option.value);\n  }, element, value);\n} /* eslint-disable no-restricted-syntax */\n\n\nasync function toSelect(instance, selector, valueOrText, options) {\n  const element = await (0, _toMatchElement2.default)(instance, selector, options);\n\n  const optionElements = await element.$$('option');\n\n  const optionsAttributes = await Promise.all(optionElements.map(async option => {\n    const textContentProperty = await option.getProperty('textContent');\n    const valueProperty = await option.getProperty('value');\n    return {\n      value: await valueProperty.jsonValue(),\n      textContent: await textContentProperty.jsonValue()\n    };\n  }));\n\n  const option = optionsAttributes.find(({ value, textContent }) => value === valueOrText || textContent === valueOrText);\n\n  if (!option) {\n    throw new Error(`Option not found \"${selector}\" (\"${valueOrText}\")`);\n  }\n\n  await select(page, element, option.value);\n\n  // await page.select(selector, foundValue)\n  // console.log(select.select)\n\n  // select.select()\n\n  // const foundValue = await select.$$eval(\n  //   `${selector} option`,\n  //   (options, valueOrText, selector) => {\n  //     const option = options.find(\n  //       option =>\n  //         option.value === valueOrText || option.textContent === valueOrText,\n  //     )\n  //     if (!option) {\n  //       throw new Error(`Option not found \"${selector}\" (\"${valueOrText}\")`)\n  //     }\n  //     return option.value\n  //   },\n  //   valueOrText,\n  //   selector,\n  // )\n  //\n  // await page.select(selector, foundValue)\n}\n\nexports.default = toSelect;\n\n/***/ }),\n\n/***/ \"./node_modules/expect-puppeteer/lib/matchers/toUploadFile.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/expect-puppeteer/lib/matchers/toUploadFile.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _toMatchElement = __webpack_require__(/*! ./toMatchElement */ \"./node_modules/expect-puppeteer/lib/matchers/toMatchElement.js\");\n\nvar _toMatchElement2 = _interopRequireDefault(_toMatchElement);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nasync function toUploadFile(instance, selector, file, options) {\n  const input = await (0, _toMatchElement2.default)(instance, selector, options);\n  const files = Array.isArray(file) ? file : [file];\n  await input.uploadFile(...files);\n}\n\nexports.default = toUploadFile;\n\n/***/ }),\n\n/***/ \"./node_modules/expect-puppeteer/lib/options.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/expect-puppeteer/lib/options.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nlet defaultOptionsValue = { timeout: 500 };\n\nconst setDefaultOptions = exports.setDefaultOptions = options => {\n  defaultOptionsValue = options;\n};\n\nconst getDefaultOptions = exports.getDefaultOptions = () => {\n  if (global.puppeteerConfig && global.puppeteerConfig.launch && global.puppeteerConfig.launch.slowMo && defaultOptionsValue && defaultOptionsValue.timeout) {\n    return _extends({}, defaultOptionsValue, {\n      // Multiplying slowMo by 10 is just arbitrary\n      // slowMo is applied on all Puppeteer internal methods, so it is just a \"slow\" indicator\n      // we can't use it as a real value\n      timeout: defaultOptionsValue.timeout + global.puppeteerConfig.launch.slowMo * 10\n    });\n  }\n\n  return defaultOptionsValue;\n};\n\nconst defaultOptions = exports.defaultOptions = options => _extends({}, getDefaultOptions(), options);\n\n/***/ }),\n\n/***/ \"./node_modules/expect-puppeteer/lib/utils.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/expect-puppeteer/lib/utils.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\nconst getPuppeteerType = exports.getPuppeteerType = instance => {\n  if (instance && instance.constructor && instance.constructor.name && ['Page', 'ElementHandle'].includes(instance.constructor.name) && instance.$) {\n    return instance.constructor.name;\n  }\n\n  return null;\n};\n\nconst getContext = exports.getContext = async (instance, pageFunction) => {\n  const type = getPuppeteerType(instance);\n  switch (type) {\n    case 'Page':\n      return {\n        page: instance,\n        handle: await instance.evaluateHandle(pageFunction)\n      };\n    case 'ElementHandle':\n      {\n        const executionContext = await instance.executionContext();\n        return {\n          page: await executionContext.frame(),\n          handle: instance\n        };\n      }\n    default:\n      throw new Error(`${type} is not implemented`);\n  }\n};\n\nconst enhanceError = exports.enhanceError = (error, message) => {\n  error.message = `${message}\\n${error.message}`;\n  return error;\n};\n\nconst isRegExp = input => Object.prototype.toString.call(input) === '[object RegExp]';\n\nconst expandSearchExpr = exports.expandSearchExpr = expr => {\n  if (isRegExp(expr)) return { text: null, regexp: expr.toString() };\n  if (typeof expr === 'string') return { text: expr, regexp: null };\n  return { text: null, regexp: null };\n};\n\n/***/ }),\n\n/***/ \"./sanities/healthcheck.test.js\":\n/*!**************************************!*\\\n  !*** ./sanities/healthcheck.test.js ***!\n  \\**************************************/\n/*! no exports provided */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var expect_puppeteer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! expect-puppeteer */ \"./node_modules/expect-puppeteer/lib/index.js\");\n/* harmony import */ var expect_puppeteer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(expect_puppeteer__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * @Owner Experience: Assessment\n * @Slack #devops\n * @Description \n *  - confirms healthcheck api loads\n*/\n\n\n\nconst constants = __webpack_require__(/*! ../constants/constants */ \"./constants/constants.js\");\n\ndescribe('Baseline', async () => {\n    Object(expect_puppeteer__WEBPACK_IMPORTED_MODULE_0__[\"setDefaultOptions\"])({ timeout: constants.defaultTimeout });\n\n    test('Tophat responds successfully', async () => {\n        await page.goto(constants.URL + '/health_check/');\n        await expect(123123).toEqual(\"asdasdas\");\n    }, 900000);\n});\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vY29uc3RhbnRzL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhwZWN0LXB1cHBldGVlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4cGVjdC1wdXBwZXRlZXIvbGliL21hdGNoZXJzL25vdFRvTWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4cGVjdC1wdXBwZXRlZXIvbGliL21hdGNoZXJzL25vdFRvTWF0Y2hFbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9leHBlY3QtcHVwcGV0ZWVyL2xpYi9tYXRjaGVycy90b0NsaWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9leHBlY3QtcHVwcGV0ZWVyL2xpYi9tYXRjaGVycy90b0Rpc3BsYXlEaWFsb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4cGVjdC1wdXBwZXRlZXIvbGliL21hdGNoZXJzL3RvRmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhwZWN0LXB1cHBldGVlci9saWIvbWF0Y2hlcnMvdG9GaWxsRm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhwZWN0LXB1cHBldGVlci9saWIvbWF0Y2hlcnMvdG9NYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhwZWN0LXB1cHBldGVlci9saWIvbWF0Y2hlcnMvdG9NYXRjaEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4cGVjdC1wdXBwZXRlZXIvbGliL21hdGNoZXJzL3RvU2VsZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9leHBlY3QtcHVwcGV0ZWVyL2xpYi9tYXRjaGVycy90b1VwbG9hZEZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4cGVjdC1wdXBwZXRlZXIvbGliL29wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4cGVjdC1wdXBwZXRlZXIvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL3Nhbml0aWVzL2hlYWx0aGNoZWNrLnRlc3QuanMiXSwibmFtZXMiOlsiY29tbW9uQ29uc3RhbnRzIiwiZGVmYXVsdFRpbWVvdXQiLCJjb25zdGFudHMiLCJDQSIsIlRFU1RfQ09VUlNFX0lEIiwiVEVTVF9QUkVTRU5UQVRJT05fQ09VUlNFX0lEIiwiVEVTVF9TTElERV9UUkFOU0lUSU9OX0NPVVJTRV9JRCIsIlRFU1RfU0xJREVfUFJFU0VOVEFUSU9OX01PRFVMRV9JVEVNX0lEIiwiVVJMIiwiVVNFUk5BTUVfUFJPRiIsIlVTRVJOQU1FX1NUVUQiLCJQQVNTV09SRCIsIlNDSE9PTCIsIkNSRURJVF9DQVJEX1NFQ1JFVF9LRVkiLCJDT1VQT05fQ09ERV9TRUNSRVRfS0VZIiwiU0VOREdSSURfQVBJX1NFQ1JFVF9LRVkiLCJTTVNfUkVTUE9OU0UiLCJDT1VSU0VfSUQiLCJQSU5QT0lOVF9QUk9KRUNUX05BTUUiLCJBTk9OX0FDQ0VTUyIsIkVYUEVDVEVEX1JFU1VMVCIsIkNPVVJTRV9TRUFSQ0giLCJTVFVERU5UX01BTkFHRVIiLCJVUyIsIklNUE9SVF9GUk9NX01BUktFVFBMQUNFIiwiQ09VUlNFX05BTUUiLCJPTERfUEFJRF9SRUciLCJTVEFHSU5HIiwiZW52IiwicHJvY2VzcyIsIkFQUF9FTlYiLCJnbG9iYWwiLCJTQU5JVFlfVkFSSUFCTEVTIiwibW9kdWxlIiwiZXhwb3J0cyIsIk9iamVjdCIsImFzc2lnbiIsInJlcXVpcmUiLCJkZXNjcmliZSIsInNldERlZmF1bHRPcHRpb25zIiwidGltZW91dCIsInRlc3QiLCJwYWdlIiwiZ290byIsImV4cGVjdCIsInRvRXF1YWwiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LEtBQUtDLElBQUwsQ0FBVXpDLFVBQVVNLEdBQVYsR0FBZ0IsZ0JBQTFCLENBQU47QUFDQSxjQUFNb0MsT0FBTyxNQUFQLEVBQWVDLE9BQWYsQ0FBdUIsVUFBdkIsQ0FBTjtBQUNILEtBSEQsRUFHRSxNQUhGO0FBSUgsQ0FQRCxFIiwiZmlsZSI6ImhlYWx0aGNoZWNrLnRlc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3Nhbml0aWVzL2hlYWx0aGNoZWNrLnRlc3QuanNcIik7XG4iLCIvKlxuICogRGVjbGFyZXMgY29uc3RhbnRzIHVzZWQgYWNyb3NzIG11bHRpcGxlIHRlc3RzXG4gKlxuICogY29uc3QgZW52ID0gKGdsb2JhbC5TQU5JVFlfVkFSSUFCTEVTLkFQUF9FTlYgPT0gJ0NBJykgPyAoJ0NBJykgOiAoJ1VTJylcbiAqIGNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL2NvbnN0YW50cycpW2Vudl07XG4gKlxuICovXG5cblxuXG5jb21tb25Db25zdGFudHMgPSB7XG4gICAgIGRlZmF1bHRUaW1lb3V0OiA2MDAwMFxuIH1cbiBcbmNvbnN0YW50cyA9IHtcbiAgICBDQToge1xuICAgICAgICBURVNUX0NPVVJTRV9JRDogJzY4OTMxNicsXG4gICAgICAgIFRFU1RfUFJFU0VOVEFUSU9OX0NPVVJTRV9JRDogJzY4MTYxNicsXG4gICAgICAgIFRFU1RfU0xJREVfVFJBTlNJVElPTl9DT1VSU0VfSUQ6ICcyMTkxODQnLFxuICAgICAgICBURVNUX1NMSURFX1BSRVNFTlRBVElPTl9NT0RVTEVfSVRFTV9JRDogJzI1MTc5NjgnLFxuICAgICAgICBVUkw6IFwiaHR0cHM6Ly9hcHAtY2EudG9waGF0LmNvbVwiLFxuICAgICAgICBVU0VSTkFNRV9QUk9GOiBcInNhbml0eStwcm9mMEB0b3BoYXRtb25vY2xlLmNvbVwiLFxuICAgICAgICBVU0VSTkFNRV9TVFVEOiBcInNhbml0eStzdHVkMEB0b3BoYXRtb25vY2xlLmNvbVwiLFxuICAgICAgICBQQVNTV09SRDogXCIxcTJ3M2VcIixcbiAgICAgICAgU0NIT09MOiBcIlByb2Zlc3NvciBUZXN0IE9yZ2FuaXphdGlvbiBDQVwiLFxuICAgICAgICBDUkVESVRfQ0FSRF9TRUNSRVRfS0VZOiBcInNhbml0eV9ydW5uZXIvY3JlZGl0X2NhcmRcIixcbiAgICAgICAgQ09VUE9OX0NPREVfU0VDUkVUX0tFWTogXCJzYW5pdHlfcnVubmVyL2NvdXBvbl9jb2RlX2NhXCIsXG4gICAgICAgIFNFTkRHUklEX0FQSV9TRUNSRVRfS0VZOiBcInNhbml0eV9ydW5uZXIvc2VuZGdyaWRfYXBpXCIsXG4gICAgICAgIFNNU19SRVNQT05TRToge1xuICAgICAgICAgICAgQ09VUlNFX0lEOiAnMDM3NTY1JyxcbiAgICAgICAgICAgIFBJTlBPSU5UX1BST0pFQ1RfTkFNRTogXCJzYW5pdHktcnVubmVyLXVzXCIsXG4gICAgICAgICAgICBVU0VSTkFNRV9TVFVEOiBcImRldm9wcyttb25pdG9yaW5nc2FuaXR5c21zMkB0b3BoYXQuY29tXCIsXG4gICAgICAgIH0sXG4gICAgICAgIEFOT05fQUNDRVNTOntcbiAgICAgICAgICAgIENPVVJTRV9JRDogJzIxMjEyNycsXG4gICAgICAgICAgICBFWFBFQ1RFRF9SRVNVTFQ6ICdBbm9uIEFjY2VzcydcbiAgICAgICAgfSxcbiAgICAgICAgQ09VUlNFX1NFQVJDSDoge1xuICAgICAgICAgICAgRVhQRUNURURfUkVTVUxUOiAnQ2FuYWRpYW4gSGlzdG9yeSdcbiAgICAgICAgfSxcbiAgICAgICAgU1RVREVOVF9NQU5BR0VSOiB7XG4gICAgICAgICAgICBFWFBFQ1RFRF9SRVNVTFQ6ICdUb3AgSGF0OiBJbnZpdGF0aW9uIHRvIGpvaW4gY291cnNlJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICBVUzoge1xuICAgICAgICBURVNUX0NPVVJTRV9JRDogJzM2Njg0NycsXG4gICAgICAgIFRFU1RfUFJFU0VOVEFUSU9OX0NPVVJTRV9JRDogJzcyNTk4OScsXG4gICAgICAgIFRFU1RfU0xJREVfVFJBTlNJVElPTl9DT1VSU0VfSUQ6ICc2NTgwMjEnLFxuICAgICAgICBURVNUX1NMSURFX1BSRVNFTlRBVElPTl9NT0RVTEVfSVRFTV9JRDogJzEzMTg0MTIxMCcsXG4gICAgICAgIFVSTDogXCJodHRwczovL2FwcC50b3BoYXQuY29tXCIsXG4gICAgICAgIFVTRVJOQU1FX1BST0Y6ICdzYW5pdHkrcHJvZjBAdG9waGF0bW9ub2NsZS5jb20nLFxuICAgICAgICBVU0VSTkFNRV9TVFVEOiAnc2FuaXR5K3N0dWQwQHRvcGhhdG1vbm9jbGUuY29tJyxcbiAgICAgICAgUEFTU1dPUkQ6IFwiMXEydzNlXCIsXG4gICAgICAgIFNDSE9PTDogXCJUb3AgSGF0IFVuaXZlcnNpdHkgLSBEZW1vc1wiLFxuICAgICAgICBDUkVESVRfQ0FSRF9TRUNSRVRfS0VZOiBcInNhbml0eV9ydW5uZXIvY3JlZGl0X2NhcmRcIixcbiAgICAgICAgQ09VUE9OX0NPREVfU0VDUkVUX0tFWTogXCJzYW5pdHlfcnVubmVyL2NvdXBvbl9jb2RlX3VzXCIsXG4gICAgICAgIFNFTkRHUklEX0FQSV9TRUNSRVRfS0VZOiBcInNhbml0eV9ydW5uZXIvc2VuZGdyaWRfYXBpXCIsXG4gICAgICAgIFNNU19SRVNQT05TRToge1xuICAgICAgICAgICAgQ09VUlNFX0lEOiAnMDk1NjgwJyxcbiAgICAgICAgICAgIFBJTlBPSU5UX1BST0pFQ1RfTkFNRTogXCJzYW5pdHktcnVubmVyLXVzXCIsXG4gICAgICAgICAgICBVU0VSTkFNRV9TVFVEOiBcImRldm9wcyttb25pdG9yaW5nc2FuaXR5c21zMkB0b3BoYXQuY29tXCIsXG4gICAgICAgIH0sXG4gICAgICAgIEFOT05fQUNDRVNTOntcbiAgICAgICAgICAgIENPVVJTRV9JRDogJzU3OTkwNScsXG4gICAgICAgICAgICBFWFBFQ1RFRF9SRVNVTFQ6ICdBbm9ueW1vdXMgQWNjZXNzJ1xuICAgICAgICB9LFxuICAgICAgICBDT1VSU0VfU0VBUkNIOiB7XG4gICAgICAgICAgICBFWFBFQ1RFRF9SRVNVTFQ6ICdBbWVyaWNhbiBIaXN0b3J5J1xuICAgICAgICB9LFxuICAgICAgICBTVFVERU5UX01BTkFHRVI6IHtcbiAgICAgICAgICAgIEVYUEVDVEVEX1JFU1VMVDogJ1RvcCBIYXQ6IEludml0YXRpb24gdG8gam9pbiBjb3Vyc2UnXG4gICAgICAgIH0sXG4gICAgICAgIElNUE9SVF9GUk9NX01BUktFVFBMQUNFOiB7XG4gICAgICAgICAgICBDT1VSU0VfSUQ6ICc1MjE4NjYnLFxuICAgICAgICAgICAgQ09VUlNFX05BTUU6ICdNb25pdG9yaW5nIDEwNSdcbiAgICAgICAgfSxcbiAgICAgICAgT0xEX1BBSURfUkVHOntcbiAgICAgICAgICAgIENPVVJTRV9JRDogJzczNjI5OCdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgU1RBR0lORzogeyBcbiAgICAgICAgVVNFUk5BTUVfUFJPRjogJ2Rldm9wcytzYW5pdHlwcm9mZXNzb3IxNTYwMTg3NTk1MjA2QHRvcGhhdG1vbm9jbGUuY29tJyxcbiAgICAgICAgVVNFUk5BTUVfU1RVRDogJ2Rldm9wcytzYW5pdHlzdHVkZW50MTU2MDE4NzU5NTIwNkB0b3BoYXRtb25vY2xlLmNvbScsXG4gICAgICAgIENSRURJVF9DQVJEX1NFQ1JFVF9LRVk6ICdzYW5pdHlfcnVubmVyL2NyZWRpdF9jYXJkJyxcbiAgICAgICAgQ09VUE9OX0NPREVfU0VDUkVUX0tFWTogJ3Nhbml0eV9ydW5uZXIvY291cG9uX2NvZGVfdXMnLFxuICAgICAgICBTRU5ER1JJRF9BUElfU0VDUkVUX0tFWTogJ3Nhbml0eV9ydW5uZXIvc2VuZGdyaWRfYXBpJyxcbiAgICAgICAgU01TX1JFU1BPTlNFOiB7IFxuICAgICAgICAgICAgICAgIENPVVJTRV9JRDogJzIxNzA3NycsXG4gICAgICAgICAgICAgICAgUElOUE9JTlRfUFJPSkVDVF9OQU1FOiAnc2FuaXR5LXJ1bm5lci11cycsXG4gICAgICAgICAgICAgICAgVVNFUk5BTUVfU1RVRDogJ2Rldm9wcyttb25pdG9yaW5nc2FuaXR5c21zMkB0b3BoYXQuY29tJyBcbiAgICAgICAgfSxcbiAgICAgICAgUEFTU1dPUkQ6ICcxcTJ3M2UnLFxuICAgICAgICBTQ0hPT0w6ICdUb3BIYXQgVW5pdmVyc2l0eScsXG4gICAgICAgIFVSTDogJ2h0dHBzOi8vc3RhZ2luZy5kZXYudG9waGF0LmNvbScsXG4gICAgICAgIFRFU1RfQ09VUlNFX0lEOiAnMTM3NTU5JyxcbiAgICAgICAgVEVTVF9QUkVTRU5UQVRJT05fQ09VUlNFX0lEOiAnMTExMTUwJyxcbiAgICAgICAgVEVTVF9TTElERV9UUkFOU0lUSU9OX0NPVVJTRV9JRDogJzc3NzcwMScsXG4gICAgICAgIEFOT05fQUNDRVNTOntcbiAgICAgICAgICAgIENPVVJTRV9JRDogJzU3OTkwNScsXG4gICAgICAgICAgICBFWFBFQ1RFRF9SRVNVTFQ6ICdBbm9ueW1vdXMgQWNjZXNzJ1xuICAgICAgICB9LFxuICAgICAgICBDT1VSU0VfU0VBUkNIOiB7XG4gICAgICAgICAgICBFWFBFQ1RFRF9SRVNVTFQ6ICdBbWVyaWNhbiBIaXN0b3J5J1xuICAgICAgICB9LFxuICAgICAgICBTVFVERU5UX01BTkFHRVI6IHtcbiAgICAgICAgICAgIEVYUEVDVEVEX1JFU1VMVDogJ1RvcCBIYXQ6IEludml0YXRpb24gdG8gam9pbiBjb3Vyc2UnXG4gICAgICAgIH0sXG4gICAgICAgIElNUE9SVF9GUk9NX01BUktFVFBMQUNFOiB7XG4gICAgICAgICAgICBDT1VSU0VfSUQ6ICc5MjYzMjInXG4gICAgICAgIH1cbiAgICB9LFxuXG59XG5cbmNvbnN0IGVudiA9IHByb2Nlc3MuZW52LkFQUF9FTlYgPyBwcm9jZXNzLmVudi5BUFBfRU5WIDogZ2xvYmFsLlNBTklUWV9WQVJJQUJMRVMuQVBQX0VOVlxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduKHt9LCBjb21tb25Db25zdGFudHMsIGNvbnN0YW50c1tlbnZdKSIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgLyogZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUsIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1hd2FpdC1pbi1sb29wICovXG5cblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF9ub3RUb01hdGNoID0gcmVxdWlyZSgnLi9tYXRjaGVycy9ub3RUb01hdGNoJyk7XG5cbnZhciBfbm90VG9NYXRjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub3RUb01hdGNoKTtcblxudmFyIF9ub3RUb01hdGNoRWxlbWVudCA9IHJlcXVpcmUoJy4vbWF0Y2hlcnMvbm90VG9NYXRjaEVsZW1lbnQnKTtcblxudmFyIF9ub3RUb01hdGNoRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub3RUb01hdGNoRWxlbWVudCk7XG5cbnZhciBfdG9DbGljayA9IHJlcXVpcmUoJy4vbWF0Y2hlcnMvdG9DbGljaycpO1xuXG52YXIgX3RvQ2xpY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9DbGljayk7XG5cbnZhciBfdG9EaXNwbGF5RGlhbG9nID0gcmVxdWlyZSgnLi9tYXRjaGVycy90b0Rpc3BsYXlEaWFsb2cnKTtcblxudmFyIF90b0Rpc3BsYXlEaWFsb2cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9EaXNwbGF5RGlhbG9nKTtcblxudmFyIF90b0ZpbGwgPSByZXF1aXJlKCcuL21hdGNoZXJzL3RvRmlsbCcpO1xuXG52YXIgX3RvRmlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b0ZpbGwpO1xuXG52YXIgX3RvRmlsbEZvcm0gPSByZXF1aXJlKCcuL21hdGNoZXJzL3RvRmlsbEZvcm0nKTtcblxudmFyIF90b0ZpbGxGb3JtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvRmlsbEZvcm0pO1xuXG52YXIgX3RvTWF0Y2ggPSByZXF1aXJlKCcuL21hdGNoZXJzL3RvTWF0Y2gnKTtcblxudmFyIF90b01hdGNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvTWF0Y2gpO1xuXG52YXIgX3RvTWF0Y2hFbGVtZW50ID0gcmVxdWlyZSgnLi9tYXRjaGVycy90b01hdGNoRWxlbWVudCcpO1xuXG52YXIgX3RvTWF0Y2hFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvTWF0Y2hFbGVtZW50KTtcblxudmFyIF90b1NlbGVjdCA9IHJlcXVpcmUoJy4vbWF0Y2hlcnMvdG9TZWxlY3QnKTtcblxudmFyIF90b1NlbGVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b1NlbGVjdCk7XG5cbnZhciBfdG9VcGxvYWRGaWxlID0gcmVxdWlyZSgnLi9tYXRjaGVycy90b1VwbG9hZEZpbGUnKTtcblxudmFyIF90b1VwbG9hZEZpbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9VcGxvYWRGaWxlKTtcblxudmFyIF9vcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IHBhZ2VNYXRjaGVycyA9IHtcbiAgdG9DbGljazogX3RvQ2xpY2syLmRlZmF1bHQsXG4gIHRvRGlzcGxheURpYWxvZzogX3RvRGlzcGxheURpYWxvZzIuZGVmYXVsdCxcbiAgdG9GaWxsOiBfdG9GaWxsMi5kZWZhdWx0LFxuICB0b0ZpbGxGb3JtOiBfdG9GaWxsRm9ybTIuZGVmYXVsdCxcbiAgdG9NYXRjaDogX3RvTWF0Y2gyLmRlZmF1bHQsXG4gIHRvTWF0Y2hFbGVtZW50OiBfdG9NYXRjaEVsZW1lbnQyLmRlZmF1bHQsXG4gIHRvU2VsZWN0OiBfdG9TZWxlY3QyLmRlZmF1bHQsXG4gIHRvVXBsb2FkRmlsZTogX3RvVXBsb2FkRmlsZTIuZGVmYXVsdCxcbiAgbm90OiB7XG4gICAgdG9NYXRjaDogX25vdFRvTWF0Y2gyLmRlZmF1bHQsXG4gICAgdG9NYXRjaEVsZW1lbnQ6IF9ub3RUb01hdGNoRWxlbWVudDIuZGVmYXVsdFxuICB9XG59O1xuXG5jb25zdCBlbGVtZW50SGFuZGxlTWF0Y2hlcnMgPSB7XG4gIHRvQ2xpY2s6IF90b0NsaWNrMi5kZWZhdWx0LFxuICB0b0ZpbGw6IF90b0ZpbGwyLmRlZmF1bHQsXG4gIHRvRmlsbEZvcm06IF90b0ZpbGxGb3JtMi5kZWZhdWx0LFxuICB0b01hdGNoOiBfdG9NYXRjaDIuZGVmYXVsdCxcbiAgdG9NYXRjaEVsZW1lbnQ6IF90b01hdGNoRWxlbWVudDIuZGVmYXVsdCxcbiAgdG9TZWxlY3Q6IF90b1NlbGVjdDIuZGVmYXVsdCxcbiAgdG9VcGxvYWRGaWxlOiBfdG9VcGxvYWRGaWxlMi5kZWZhdWx0LFxuICBub3Q6IHtcbiAgICB0b01hdGNoOiBfbm90VG9NYXRjaDIuZGVmYXVsdCxcbiAgICB0b01hdGNoRWxlbWVudDogX25vdFRvTWF0Y2hFbGVtZW50Mi5kZWZhdWx0XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIobWF0Y2hlciwgcGFnZSkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gdGhyb3dpbmdNYXRjaGVyKC4uLmFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5leHBlY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwuZXhwZWN0LmdldFN0YXRlKCkuYXNzZXJ0aW9uQ2FsbHMgKz0gMTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IG1hdGNoZXIocGFnZSwgLi4uYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBjcmVhdGVNYXRjaGVyKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxFeHBlY3QodHlwZSwgbWF0Y2hlcnMpIHtcbiAgY29uc3QgZXhwZWN0YXRpb24gPSB7XG4gICAgbm90OiB7fVxuICB9O1xuXG4gIE9iamVjdC5rZXlzKG1hdGNoZXJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKGtleSA9PT0gJ25vdCcpIHJldHVybjtcbiAgICBleHBlY3RhdGlvbltrZXldID0gY3JlYXRlTWF0Y2hlcihtYXRjaGVyc1trZXldLCB0eXBlKTtcbiAgfSk7XG5cbiAgT2JqZWN0LmtleXMobWF0Y2hlcnMubm90KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgZXhwZWN0YXRpb24ubm90W2tleV0gPSBjcmVhdGVNYXRjaGVyKG1hdGNoZXJzLm5vdFtrZXldLCB0eXBlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGV4cGVjdGF0aW9uO1xufVxuXG5mdW5jdGlvbiBleHBlY3RQdXBwZXRlZXIoYWN0dWFsKSB7XG4gIGNvbnN0IHR5cGUgPSAoMCwgX3V0aWxzLmdldFB1cHBldGVlclR5cGUpKGFjdHVhbCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BhZ2UnOlxuICAgICAgcmV0dXJuIGludGVybmFsRXhwZWN0KGFjdHVhbCwgcGFnZU1hdGNoZXJzKTtcbiAgICBjYXNlICdFbGVtZW50SGFuZGxlJzpcbiAgICAgIHJldHVybiBpbnRlcm5hbEV4cGVjdChhY3R1YWwsIGVsZW1lbnRIYW5kbGVNYXRjaGVycyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHthY3R1YWx9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxufVxuXG5pZiAodHlwZW9mIGdsb2JhbC5leHBlY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gIGNvbnN0IG9yaWdpbmFsRXhwZWN0ID0gZ2xvYmFsLmV4cGVjdDtcbiAgZ2xvYmFsLmV4cGVjdCA9IChhY3R1YWwsIC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCB0eXBlID0gKDAsIF91dGlscy5nZXRQdXBwZXRlZXJUeXBlKShhY3R1YWwpO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBjb25zdCBtYXRjaGVycyA9IGV4cGVjdFB1cHBldGVlcihhY3R1YWwpO1xuICAgICAgY29uc3QgamVzdE1hdGNoZXJzID0gb3JpZ2luYWxFeHBlY3QoYWN0dWFsLCAuLi5hcmdzKTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgamVzdE1hdGNoZXJzLCBtYXRjaGVycywge1xuICAgICAgICBub3Q6IF9leHRlbmRzKHt9LCBqZXN0TWF0Y2hlcnMubm90LCBtYXRjaGVycy5ub3QpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdpbmFsRXhwZWN0KGFjdHVhbCwgLi4uYXJncyk7XG4gIH07XG4gIE9iamVjdC5rZXlzKG9yaWdpbmFsRXhwZWN0KS5mb3JFYWNoKHByb3AgPT4ge1xuICAgIGdsb2JhbC5leHBlY3RbcHJvcF0gPSBvcmlnaW5hbEV4cGVjdFtwcm9wXTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwZWN0UHVwcGV0ZWVyO1xubW9kdWxlLmV4cG9ydHMuc2V0RGVmYXVsdE9wdGlvbnMgPSBfb3B0aW9ucy5zZXREZWZhdWx0T3B0aW9ucztcbm1vZHVsZS5leHBvcnRzLmdldERlZmF1bHRPcHRpb25zID0gX29wdGlvbnMuZ2V0RGVmYXVsdE9wdGlvbnM7IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIF9vcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucycpO1xuXG5hc3luYyBmdW5jdGlvbiBub3RUb01hdGNoKGluc3RhbmNlLCBtYXRjaGVyLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSAoMCwgX29wdGlvbnMuZGVmYXVsdE9wdGlvbnMpKG9wdGlvbnMpO1xuXG4gIGNvbnN0IHsgcGFnZSwgaGFuZGxlIH0gPSBhd2FpdCAoMCwgX3V0aWxzLmdldENvbnRleHQpKGluc3RhbmNlLCAoKSA9PiBkb2N1bWVudC5ib2R5KTtcblxuICB0cnkge1xuICAgIGF3YWl0IHBhZ2Uud2FpdEZvckZ1bmN0aW9uKChoYW5kbGUsIG1hdGNoZXIpID0+IHtcbiAgICAgIGlmICghaGFuZGxlKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gaGFuZGxlLnRleHRDb250ZW50Lm1hdGNoKG5ldyBSZWdFeHAobWF0Y2hlcikpID09PSBudWxsO1xuICAgIH0sIG9wdGlvbnMsIGhhbmRsZSwgbWF0Y2hlcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgKDAsIF91dGlscy5lbmhhbmNlRXJyb3IpKGVycm9yLCBgVGV4dCBmb3VuZCBcIiR7bWF0Y2hlcn1cImApO1xuICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5vdFRvTWF0Y2g7IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIF9vcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucycpO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmFzeW5jIGZ1bmN0aW9uIG5vdFRvTWF0Y2hFbGVtZW50KGluc3RhbmNlLCBzZWxlY3RvciwgX3JlZiA9IHt9KSB7XG4gIGxldCB7IHRleHQgfSA9IF9yZWYsXG4gICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsndGV4dCddKTtcblxuICBvcHRpb25zID0gKDAsIF9vcHRpb25zLmRlZmF1bHRPcHRpb25zKShvcHRpb25zKTtcblxuICBjb25zdCB7IHBhZ2UsIGhhbmRsZSB9ID0gYXdhaXQgKDAsIF91dGlscy5nZXRDb250ZXh0KShpbnN0YW5jZSwgKCkgPT4gZG9jdW1lbnQpO1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgcGFnZS53YWl0Rm9yRnVuY3Rpb24oKGhhbmRsZSwgc2VsZWN0b3IsIHRleHQpID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gaGFuZGxlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgaWYgKHRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gWy4uLmVsZW1lbnRzXS5ldmVyeSgoeyB0ZXh0Q29udGVudCB9KSA9PiAhdGV4dENvbnRlbnQubWF0Y2godGV4dCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlbWVudHMubGVuZ3RoID09PSAwO1xuICAgIH0sIG9wdGlvbnMsIGhhbmRsZSwgc2VsZWN0b3IsIHRleHQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93ICgwLCBfdXRpbHMuZW5oYW5jZUVycm9yKShlcnJvciwgYEVsZW1lbnQgJHtzZWxlY3Rvcn0ke3RleHQgIT09IHVuZGVmaW5lZCA/IGAgKHRleHQ6IFwiJHt0ZXh0fVwiKSBgIDogJyAnfWZvdW5kYCk7XG4gIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbm90VG9NYXRjaEVsZW1lbnQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3RvTWF0Y2hFbGVtZW50ID0gcmVxdWlyZSgnLi90b01hdGNoRWxlbWVudCcpO1xuXG52YXIgX3RvTWF0Y2hFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvTWF0Y2hFbGVtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuYXN5bmMgZnVuY3Rpb24gdG9DbGljayhpbnN0YW5jZSwgc2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgZWxlbWVudCA9IGF3YWl0ICgwLCBfdG9NYXRjaEVsZW1lbnQyLmRlZmF1bHQpKGluc3RhbmNlLCBzZWxlY3Rvciwgb3B0aW9ucyk7XG4gIGF3YWl0IGVsZW1lbnQuY2xpY2sob3B0aW9ucyk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHRvQ2xpY2s7IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuYXN5bmMgZnVuY3Rpb24gdG9EaXNwbGF5RGlhbG9nKHBhZ2UsIGJsb2NrKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyByZXNvbHZlID0+IHtcbiAgICBjb25zdCBoYW5kbGVEaWFsb2cgPSBkaWFsb2cgPT4ge1xuICAgICAgcGFnZS5yZW1vdmVMaXN0ZW5lcignZGlhbG9nJywgaGFuZGxlRGlhbG9nKTtcbiAgICAgIHJlc29sdmUoZGlhbG9nKTtcbiAgICB9O1xuICAgIHBhZ2Uub24oJ2RpYWxvZycsIGhhbmRsZURpYWxvZyk7XG4gICAgYXdhaXQgYmxvY2soKTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHRvRGlzcGxheURpYWxvZzsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdG9NYXRjaEVsZW1lbnQgPSByZXF1aXJlKCcuL3RvTWF0Y2hFbGVtZW50Jyk7XG5cbnZhciBfdG9NYXRjaEVsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9NYXRjaEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmFzeW5jIGZ1bmN0aW9uIHRvRmlsbChpbnN0YW5jZSwgc2VsZWN0b3IsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9yZWYgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICB7IGRlbGF5IH0gPSBfcmVmLFxuICAgICAgICB0b01hdGNoRWxlbWVudE9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydkZWxheSddKTtcbiAgY29uc3QgZWxlbWVudCA9IGF3YWl0ICgwLCBfdG9NYXRjaEVsZW1lbnQyLmRlZmF1bHQpKGluc3RhbmNlLCBzZWxlY3RvciwgdG9NYXRjaEVsZW1lbnRPcHRpb25zKTtcbiAgYXdhaXQgZWxlbWVudC5jbGljayh7IGNsaWNrQ291bnQ6IDMgfSk7XG4gIGF3YWl0IGVsZW1lbnQudHlwZSh2YWx1ZSwge1xuICAgIGRlbGF5XG4gIH0pO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0b0ZpbGw7IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX29wdGlvbnMgPSByZXF1aXJlKCcuLi9vcHRpb25zJyk7XG5cbnZhciBfdG9GaWxsID0gcmVxdWlyZSgnLi90b0ZpbGwnKTtcblxudmFyIF90b0ZpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9GaWxsKTtcblxudmFyIF90b01hdGNoRWxlbWVudCA9IHJlcXVpcmUoJy4vdG9NYXRjaEVsZW1lbnQnKTtcblxudmFyIF90b01hdGNoRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b01hdGNoRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1hd2FpdC1pbi1sb29wICovXG5hc3luYyBmdW5jdGlvbiB0b0ZpbGxGb3JtKGluc3RhbmNlLCBzZWxlY3RvciwgdmFsdWVzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSAoMCwgX29wdGlvbnMuZGVmYXVsdE9wdGlvbnMpKG9wdGlvbnMpO1xuXG4gIGNvbnN0IGZvcm0gPSBhd2FpdCAoMCwgX3RvTWF0Y2hFbGVtZW50Mi5kZWZhdWx0KShpbnN0YW5jZSwgc2VsZWN0b3IsIG9wdGlvbnMpO1xuXG4gIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyh2YWx1ZXMpKSB7XG4gICAgYXdhaXQgKDAsIF90b0ZpbGwyLmRlZmF1bHQpKGZvcm0sIGBbbmFtZT1cIiR7bmFtZX1cIl1gLCB2YWx1ZXNbbmFtZV0sIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHRvRmlsbEZvcm07IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIF9vcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucycpO1xuXG5hc3luYyBmdW5jdGlvbiB0b01hdGNoKGluc3RhbmNlLCBtYXRjaGVyLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSAoMCwgX29wdGlvbnMuZGVmYXVsdE9wdGlvbnMpKG9wdGlvbnMpO1xuXG4gIGNvbnN0IHsgcGFnZSwgaGFuZGxlIH0gPSBhd2FpdCAoMCwgX3V0aWxzLmdldENvbnRleHQpKGluc3RhbmNlLCAoKSA9PiBkb2N1bWVudC5ib2R5KTtcblxuICBjb25zdCB7IHRleHQsIHJlZ2V4cCB9ID0gKDAsIF91dGlscy5leHBhbmRTZWFyY2hFeHByKShtYXRjaGVyKTtcblxuICB0cnkge1xuICAgIGF3YWl0IHBhZ2Uud2FpdEZvckZ1bmN0aW9uKChoYW5kbGUsIHRleHQsIHJlZ2V4cCkgPT4ge1xuICAgICAgaWYgKCFoYW5kbGUpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChyZWdleHAgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgWywgcGF0dGVybiwgZmxhZ3NdID0gcmVnZXhwLm1hdGNoKC9cXC8oLiopXFwvKC4qKT8vKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpLm1hdGNoKG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpKSAhPT0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGUudGV4dENvbnRlbnQucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKS5pbmNsdWRlcyh0ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBvcHRpb25zLCBoYW5kbGUsIHRleHQsIHJlZ2V4cCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgKDAsIF91dGlscy5lbmhhbmNlRXJyb3IpKGVycm9yLCBgVGV4dCBub3QgZm91bmQgXCIke21hdGNoZXJ9XCJgKTtcbiAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0b01hdGNoOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBfb3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMnKTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5hc3luYyBmdW5jdGlvbiB0b01hdGNoRWxlbWVudChpbnN0YW5jZSwgc2VsZWN0b3IsIF9yZWYgPSB7fSkge1xuICBsZXQgeyB0ZXh0OiBzZWFyY2hFeHByIH0gPSBfcmVmLFxuICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3RleHQnXSk7XG5cbiAgb3B0aW9ucyA9ICgwLCBfb3B0aW9ucy5kZWZhdWx0T3B0aW9ucykob3B0aW9ucyk7XG5cbiAgY29uc3QgeyBwYWdlLCBoYW5kbGUgfSA9IGF3YWl0ICgwLCBfdXRpbHMuZ2V0Q29udGV4dCkoaW5zdGFuY2UsICgpID0+IGRvY3VtZW50KTtcblxuICBjb25zdCB7IHRleHQsIHJlZ2V4cCB9ID0gKDAsIF91dGlscy5leHBhbmRTZWFyY2hFeHByKShzZWFyY2hFeHByKTtcblxuICBjb25zdCBnZXRFbGVtZW50ID0gKGhhbmRsZSwgc2VsZWN0b3IsIHRleHQsIHJlZ2V4cCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gaGFuZGxlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIGlmIChyZWdleHAgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IFssIHBhdHRlcm4sIGZsYWdzXSA9IHJlZ2V4cC5tYXRjaCgvXFwvKC4qKVxcLyguKik/Lyk7XG4gICAgICByZXR1cm4gWy4uLmVsZW1lbnRzXS5maW5kKCh7IHRleHRDb250ZW50IH0pID0+IHRleHRDb250ZW50LnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCkubWF0Y2gobmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncykpKTtcbiAgICB9XG4gICAgaWYgKHRleHQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBbLi4uZWxlbWVudHNdLmZpbmQoKHsgdGV4dENvbnRlbnQgfSkgPT4gdGV4dENvbnRlbnQucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKS5pbmNsdWRlcyh0ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50c1swXTtcbiAgfTtcblxuICB0cnkge1xuICAgIGF3YWl0IHBhZ2Uud2FpdEZvckZ1bmN0aW9uKGdldEVsZW1lbnQsIG9wdGlvbnMsIGhhbmRsZSwgc2VsZWN0b3IsIHRleHQsIHJlZ2V4cCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgKDAsIF91dGlscy5lbmhhbmNlRXJyb3IpKGVycm9yLCBgRWxlbWVudCAke3NlbGVjdG9yfSR7dGV4dCAhPT0gbnVsbCB8fCByZWdleHAgIT09IG51bGwgPyBgICh0ZXh0OiBcIiR7dGV4dCB8fCByZWdleHB9XCIpIGAgOiAnICd9bm90IGZvdW5kYCk7XG4gIH1cblxuICBjb25zdCBqc0hhbmRsZSA9IGF3YWl0IHBhZ2UuZXZhbHVhdGVIYW5kbGUoZ2V0RWxlbWVudCwgaGFuZGxlLCBzZWxlY3RvciwgdGV4dCwgcmVnZXhwKTtcbiAgcmV0dXJuIGpzSGFuZGxlLmFzRWxlbWVudCgpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0b01hdGNoRWxlbWVudDsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdG9NYXRjaEVsZW1lbnQgPSByZXF1aXJlKCcuL3RvTWF0Y2hFbGVtZW50Jyk7XG5cbnZhciBfdG9NYXRjaEVsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9NYXRjaEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBzZWxlY3QocGFnZSwgZWxlbWVudCwgdmFsdWUpIHtcbiAgcmV0dXJuIHBhZ2UuZXZhbHVhdGUoKGVsZW1lbnQsIHZhbHVlKSA9PiB7XG4gICAgaWYgKGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ3NlbGVjdCcpIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBpcyBub3QgYSA8c2VsZWN0PiBlbGVtZW50LicpO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IEFycmF5LmZyb20oZWxlbWVudC5vcHRpb25zKTtcbiAgICBlbGVtZW50LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlID09PSBvcHRpb24udmFsdWU7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICYmICFlbGVtZW50Lm11bHRpcGxlKSBicmVhaztcbiAgICB9XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgcmV0dXJuIG9wdGlvbnMuZmlsdGVyKG9wdGlvbiA9PiBvcHRpb24uc2VsZWN0ZWQpLm1hcChvcHRpb24gPT4gb3B0aW9uLnZhbHVlKTtcbiAgfSwgZWxlbWVudCwgdmFsdWUpO1xufSAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuXG5cbmFzeW5jIGZ1bmN0aW9uIHRvU2VsZWN0KGluc3RhbmNlLCBzZWxlY3RvciwgdmFsdWVPclRleHQsIG9wdGlvbnMpIHtcbiAgY29uc3QgZWxlbWVudCA9IGF3YWl0ICgwLCBfdG9NYXRjaEVsZW1lbnQyLmRlZmF1bHQpKGluc3RhbmNlLCBzZWxlY3Rvciwgb3B0aW9ucyk7XG5cbiAgY29uc3Qgb3B0aW9uRWxlbWVudHMgPSBhd2FpdCBlbGVtZW50LiQkKCdvcHRpb24nKTtcblxuICBjb25zdCBvcHRpb25zQXR0cmlidXRlcyA9IGF3YWl0IFByb21pc2UuYWxsKG9wdGlvbkVsZW1lbnRzLm1hcChhc3luYyBvcHRpb24gPT4ge1xuICAgIGNvbnN0IHRleHRDb250ZW50UHJvcGVydHkgPSBhd2FpdCBvcHRpb24uZ2V0UHJvcGVydHkoJ3RleHRDb250ZW50Jyk7XG4gICAgY29uc3QgdmFsdWVQcm9wZXJ0eSA9IGF3YWl0IG9wdGlvbi5nZXRQcm9wZXJ0eSgndmFsdWUnKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGF3YWl0IHZhbHVlUHJvcGVydHkuanNvblZhbHVlKCksXG4gICAgICB0ZXh0Q29udGVudDogYXdhaXQgdGV4dENvbnRlbnRQcm9wZXJ0eS5qc29uVmFsdWUoKVxuICAgIH07XG4gIH0pKTtcblxuICBjb25zdCBvcHRpb24gPSBvcHRpb25zQXR0cmlidXRlcy5maW5kKCh7IHZhbHVlLCB0ZXh0Q29udGVudCB9KSA9PiB2YWx1ZSA9PT0gdmFsdWVPclRleHQgfHwgdGV4dENvbnRlbnQgPT09IHZhbHVlT3JUZXh0KTtcblxuICBpZiAoIW9wdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgT3B0aW9uIG5vdCBmb3VuZCBcIiR7c2VsZWN0b3J9XCIgKFwiJHt2YWx1ZU9yVGV4dH1cIilgKTtcbiAgfVxuXG4gIGF3YWl0IHNlbGVjdChwYWdlLCBlbGVtZW50LCBvcHRpb24udmFsdWUpO1xuXG4gIC8vIGF3YWl0IHBhZ2Uuc2VsZWN0KHNlbGVjdG9yLCBmb3VuZFZhbHVlKVxuICAvLyBjb25zb2xlLmxvZyhzZWxlY3Quc2VsZWN0KVxuXG4gIC8vIHNlbGVjdC5zZWxlY3QoKVxuXG4gIC8vIGNvbnN0IGZvdW5kVmFsdWUgPSBhd2FpdCBzZWxlY3QuJCRldmFsKFxuICAvLyAgIGAke3NlbGVjdG9yfSBvcHRpb25gLFxuICAvLyAgIChvcHRpb25zLCB2YWx1ZU9yVGV4dCwgc2VsZWN0b3IpID0+IHtcbiAgLy8gICAgIGNvbnN0IG9wdGlvbiA9IG9wdGlvbnMuZmluZChcbiAgLy8gICAgICAgb3B0aW9uID0+XG4gIC8vICAgICAgICAgb3B0aW9uLnZhbHVlID09PSB2YWx1ZU9yVGV4dCB8fCBvcHRpb24udGV4dENvbnRlbnQgPT09IHZhbHVlT3JUZXh0LFxuICAvLyAgICAgKVxuICAvLyAgICAgaWYgKCFvcHRpb24pIHtcbiAgLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcHRpb24gbm90IGZvdW5kIFwiJHtzZWxlY3Rvcn1cIiAoXCIke3ZhbHVlT3JUZXh0fVwiKWApXG4gIC8vICAgICB9XG4gIC8vICAgICByZXR1cm4gb3B0aW9uLnZhbHVlXG4gIC8vICAgfSxcbiAgLy8gICB2YWx1ZU9yVGV4dCxcbiAgLy8gICBzZWxlY3RvcixcbiAgLy8gKVxuICAvL1xuICAvLyBhd2FpdCBwYWdlLnNlbGVjdChzZWxlY3RvciwgZm91bmRWYWx1ZSlcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdG9TZWxlY3Q7IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3RvTWF0Y2hFbGVtZW50ID0gcmVxdWlyZSgnLi90b01hdGNoRWxlbWVudCcpO1xuXG52YXIgX3RvTWF0Y2hFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvTWF0Y2hFbGVtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuYXN5bmMgZnVuY3Rpb24gdG9VcGxvYWRGaWxlKGluc3RhbmNlLCBzZWxlY3RvciwgZmlsZSwgb3B0aW9ucykge1xuICBjb25zdCBpbnB1dCA9IGF3YWl0ICgwLCBfdG9NYXRjaEVsZW1lbnQyLmRlZmF1bHQpKGluc3RhbmNlLCBzZWxlY3Rvciwgb3B0aW9ucyk7XG4gIGNvbnN0IGZpbGVzID0gQXJyYXkuaXNBcnJheShmaWxlKSA/IGZpbGUgOiBbZmlsZV07XG4gIGF3YWl0IGlucHV0LnVwbG9hZEZpbGUoLi4uZmlsZXMpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0b1VwbG9hZEZpbGU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmxldCBkZWZhdWx0T3B0aW9uc1ZhbHVlID0geyB0aW1lb3V0OiA1MDAgfTtcblxuY29uc3Qgc2V0RGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLnNldERlZmF1bHRPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGRlZmF1bHRPcHRpb25zVmFsdWUgPSBvcHRpb25zO1xufTtcblxuY29uc3QgZ2V0RGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmdldERlZmF1bHRPcHRpb25zID0gKCkgPT4ge1xuICBpZiAoZ2xvYmFsLnB1cHBldGVlckNvbmZpZyAmJiBnbG9iYWwucHVwcGV0ZWVyQ29uZmlnLmxhdW5jaCAmJiBnbG9iYWwucHVwcGV0ZWVyQ29uZmlnLmxhdW5jaC5zbG93TW8gJiYgZGVmYXVsdE9wdGlvbnNWYWx1ZSAmJiBkZWZhdWx0T3B0aW9uc1ZhbHVlLnRpbWVvdXQpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zVmFsdWUsIHtcbiAgICAgIC8vIE11bHRpcGx5aW5nIHNsb3dNbyBieSAxMCBpcyBqdXN0IGFyYml0cmFyeVxuICAgICAgLy8gc2xvd01vIGlzIGFwcGxpZWQgb24gYWxsIFB1cHBldGVlciBpbnRlcm5hbCBtZXRob2RzLCBzbyBpdCBpcyBqdXN0IGEgXCJzbG93XCIgaW5kaWNhdG9yXG4gICAgICAvLyB3ZSBjYW4ndCB1c2UgaXQgYXMgYSByZWFsIHZhbHVlXG4gICAgICB0aW1lb3V0OiBkZWZhdWx0T3B0aW9uc1ZhbHVlLnRpbWVvdXQgKyBnbG9iYWwucHVwcGV0ZWVyQ29uZmlnLmxhdW5jaC5zbG93TW8gKiAxMFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRPcHRpb25zVmFsdWU7XG59O1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBvcHRpb25zID0+IF9leHRlbmRzKHt9LCBnZXREZWZhdWx0T3B0aW9ucygpLCBvcHRpb25zKTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5jb25zdCBnZXRQdXBwZXRlZXJUeXBlID0gZXhwb3J0cy5nZXRQdXBwZXRlZXJUeXBlID0gaW5zdGFuY2UgPT4ge1xuICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuY29uc3RydWN0b3IgJiYgaW5zdGFuY2UuY29uc3RydWN0b3IubmFtZSAmJiBbJ1BhZ2UnLCAnRWxlbWVudEhhbmRsZSddLmluY2x1ZGVzKGluc3RhbmNlLmNvbnN0cnVjdG9yLm5hbWUpICYmIGluc3RhbmNlLiQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgZ2V0Q29udGV4dCA9IGV4cG9ydHMuZ2V0Q29udGV4dCA9IGFzeW5jIChpbnN0YW5jZSwgcGFnZUZ1bmN0aW9uKSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXRQdXBwZXRlZXJUeXBlKGluc3RhbmNlKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnUGFnZSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlOiBpbnN0YW5jZSxcbiAgICAgICAgaGFuZGxlOiBhd2FpdCBpbnN0YW5jZS5ldmFsdWF0ZUhhbmRsZShwYWdlRnVuY3Rpb24pXG4gICAgICB9O1xuICAgIGNhc2UgJ0VsZW1lbnRIYW5kbGUnOlxuICAgICAge1xuICAgICAgICBjb25zdCBleGVjdXRpb25Db250ZXh0ID0gYXdhaXQgaW5zdGFuY2UuZXhlY3V0aW9uQ29udGV4dCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhZ2U6IGF3YWl0IGV4ZWN1dGlvbkNvbnRleHQuZnJhbWUoKSxcbiAgICAgICAgICBoYW5kbGU6IGluc3RhbmNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0eXBlfSBpcyBub3QgaW1wbGVtZW50ZWRgKTtcbiAgfVxufTtcblxuY29uc3QgZW5oYW5jZUVycm9yID0gZXhwb3J0cy5lbmhhbmNlRXJyb3IgPSAoZXJyb3IsIG1lc3NhZ2UpID0+IHtcbiAgZXJyb3IubWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuJHtlcnJvci5tZXNzYWdlfWA7XG4gIHJldHVybiBlcnJvcjtcbn07XG5cbmNvbnN0IGlzUmVnRXhwID0gaW5wdXQgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG5cbmNvbnN0IGV4cGFuZFNlYXJjaEV4cHIgPSBleHBvcnRzLmV4cGFuZFNlYXJjaEV4cHIgPSBleHByID0+IHtcbiAgaWYgKGlzUmVnRXhwKGV4cHIpKSByZXR1cm4geyB0ZXh0OiBudWxsLCByZWdleHA6IGV4cHIudG9TdHJpbmcoKSB9O1xuICBpZiAodHlwZW9mIGV4cHIgPT09ICdzdHJpbmcnKSByZXR1cm4geyB0ZXh0OiBleHByLCByZWdleHA6IG51bGwgfTtcbiAgcmV0dXJuIHsgdGV4dDogbnVsbCwgcmVnZXhwOiBudWxsIH07XG59OyIsIi8qKlxuICogQE93bmVyIEV4cGVyaWVuY2U6IEFzc2Vzc21lbnRcbiAqIEBTbGFjayAjZGV2b3BzXG4gKiBARGVzY3JpcHRpb24gXG4gKiAgLSBjb25maXJtcyBoZWFsdGhjaGVjayBhcGkgbG9hZHNcbiovXG5cblxuaW1wb3J0IHsgc2V0RGVmYXVsdE9wdGlvbnMgfSBmcm9tICdleHBlY3QtcHVwcGV0ZWVyJ1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvY29uc3RhbnRzJyk7XG5cbmRlc2NyaWJlKCdCYXNlbGluZScsIGFzeW5jICgpID0+IHtcbiAgICBzZXREZWZhdWx0T3B0aW9ucyh7IHRpbWVvdXQ6IGNvbnN0YW50cy5kZWZhdWx0VGltZW91dCB9KVxuXG4gICAgdGVzdCgnVG9waGF0IHJlc3BvbmRzIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgcGFnZS5nb3RvKGNvbnN0YW50cy5VUkwgKyAnL2hlYWx0aF9jaGVjay8nKVxuICAgICAgICBhd2FpdCBleHBlY3QoMTIzMTIzKS50b0VxdWFsKFwiYXNkYXNkYXNcIilcbiAgICB9LDkwMDAwMClcbn0pXG4iXSwic291cmNlUm9vdCI6IiJ9"},"testVariables":{"APP_ENV":"STAGING"},"retryCount":"3"}